##### 0、
##### 1、[冒泡排序](https://github.com/lpp864019150/givemeanoffer/blob/main/algorithm/algorithm.php)
>冒泡排序是一种交换排序，它的基本思想是：两两比较相邻记录的关键字，如果反序则交换，直到没有反序的记录为止。
1. 从第一位开始，与右边相邻的进行比较，如果顺序错了则交换之，否则不动。然后往后挪一位继续比较，直到最后一位
2. 继续回到第一位，重复上面操作，直至排好序(每趟结束位置需比上一趟左移一位，因为每趟会产生一个排好序的位置)
3. 代码：需要两个循环，第一个循环控制所需的趟数，n-1趟即可；第二个循环需要每次从第一位开始逐个比对，直到n-i(i为第几趟)为止
4. 改良版：设置一个flag，若当前趟未发生位置交换，则认为已经排好序，此时提前退出循环完成排序

##### 2、[插入排序](https://github.com/lpp864019150/givemeanoffer/blob/main/algorithm/algorithm.php)
>将一个记录插入到已经排好序的有序表中，从而一个新的、记录数增1的有序表。在其实现过程使用双层循环，外层循环对除了第一个元素之外的所有元素，内层循环对当前元素前面有序表进行待插入位置查找，并进行移动
1. 左侧为有序区，右侧为无序区，每趟从右侧无序区最左侧取一个值，与左侧有序区进行比对，从右往左逐一比对，直到寻找到合适的位置插入
2. 重复上面的操作，直至右侧无序区无数据为止
3. 代码：需要两个循环，第一个循环控制所需的趟数，n-1；第二个循环取当前趟数i所在位移的数据为待排序数据，待排序数据往左一位开始由右往左逐个比对，若比它大，则往右移一位，否则待排序数据插入右后方

##### 3、[选择排序](https://github.com/lpp864019150/givemeanoffer/blob/main/algorithm/algorithm.php)
>第一次从待排序的数据元素中选出最小（或最大）的一个元素，存放在序列的起始位置，然后再从剩余的未排序元素中寻找到最小（大）元素，然后放到已排序的序列的末尾。以此类推，直到全部待排序的数据元素的个数为零。选择排序是不稳定的排序方法。
1. 左边为有序区，右边为无序区，每趟从右侧无序区选择一个最小值插入左侧有序区尾部
2. 重复上面的操作，直至右侧无序区无数据为止
3. 代码：需要两个循环，第一个循环控制所需的趟数，n-1；第二个循环从第i个数据开始逐个往右比对，寻找最小值，记录最小值的位移，若位移非i，则与i互换位置
4. ps. 为什么是非稳定排序，因为每次需从右侧无序区找一个最小值，然后与左侧有序区末尾互换位置，这样会导致两个相同的数据位置不能稳定

##### 4、[快速排序](https://github.com/lpp864019150/givemeanoffer/blob/main/algorithm/algorithm.php)
>选择一个基准数据，把小于它的放左侧，大于它的放右侧；然后分别对这两部分排序
1. 代码：以最左侧数据为基准，分别从左往右找下一个不小于基准数的位移x、从右往左找下一个不大于基准数的位移y，若x>=y结束，否则互换位置，继续寻找下一位。一趟下来会切分出两块数据，再对这两块分别进行排序，也即递归
2. 优化：在选择基准数据时，可以采取三位取中法，取最左侧、最右侧、中间位，这三者取中间值作为基准数据，尽量避免最差情况出现




